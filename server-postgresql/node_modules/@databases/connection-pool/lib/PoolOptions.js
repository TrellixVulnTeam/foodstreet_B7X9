"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PoolOptionsObject = void 0;

const errors_1 = require("./utils/errors");

const timeout_1 = require("./utils/timeout");

function zeroToInfinity(value, defaultValue = Infinity) {
  if (value === undefined) {
    return defaultValue;
  } else if (value === 0) {
    return Infinity;
  } else {
    return value;
  }
}

class PoolOptionsObject {
  constructor(options) {
    this._onConnectionAfterTimeout = connection => {
      void this.closeConnection(connection);
    };

    this._onConnectionClosed = timeout => {
      if (timeout_1.isTimeout(timeout)) {
        if (this._options.onTimeoutClosingConnection) {
          this._options.onTimeoutClosingConnection();
        } else {
          console.warn(`pool.closeConnetion timed out after ${this._closeConnectionTimeoutMilliseconds}ms`);
        }
      }
    };

    this._onConnectionError = err => {
      if (this._options.onErrorClosingConnection) {
        this._options.onErrorClosingConnection(err);
      } else {
        console.error(`Error closing connection: ${err.stack}`);
      }
    };

    this._options = options;
    this.maxSize = zeroToInfinity(options.maxSize);
    this.maxUses = zeroToInfinity(options.maxUses);
    this.idleTimeoutMilliseconds = zeroToInfinity(options.idleTimeoutMilliseconds);
    this.releaseTimeoutMilliseconds = zeroToInfinity(options.releaseTimeoutMilliseconds);
    this.queueTimeoutMilliseconds = zeroToInfinity(options.queueTimeoutMilliseconds);
    this._openConnectionTimeoutMilliseconds = zeroToInfinity(options.openConnectionTimeoutMilliseconds, 60000);
    this._closeConnectionTimeoutMilliseconds = zeroToInfinity(options.closeConnectionTimeoutMilliseconds, 60000);

    if (this._options.releaseTimeoutMilliseconds !== undefined && !this._options.onReleaseTimeout) {
      throw new Error(`If you specify releaseTimeoutMilliseconds you must provide a handler for onReleaseTimeout`);
    }
  }

  async openConnection(removeFromPool) {
    return timeout_1.withTimeout(this._options.openConnection, {
      timeoutMilliseconds: this._openConnectionTimeoutMilliseconds,
      onResultAfterTimeout: this._onConnectionAfterTimeout
    }, removeFromPool);
  }

  async closeConnection(connection) {
    return timeout_1.withTimeout(this._options.closeConnection, {
      timeoutMilliseconds: this._closeConnectionTimeoutMilliseconds
    }, connection).then(this._onConnectionClosed, this._onConnectionError).catch(errors_1.globalError);
  }

  onActive(connection) {
    return errors_1.attemptHook(this._options.onActive, connection);
  }

  onIdle(connection) {
    return errors_1.attemptHook(this._options.onIdle, connection);
  }

  onReleaseTimeout(connection) {
    void timeout_1.withTimeout(this._options.onReleaseTimeout, {
      timeoutMilliseconds: this._closeConnectionTimeoutMilliseconds
    }, connection).then(this._onConnectionClosed, this._onConnectionError).catch(errors_1.globalError);
  }

}

exports.PoolOptionsObject = PoolOptionsObject;